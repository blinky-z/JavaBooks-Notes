# Java Concurrency In Practice, Brian Goetz

### Что такое event loop (общее понятие)?

**Event loop (цикл событий)** - это луп, который ожидает новых ивентов, а далее передает ивент в обработчик ивента. Ивент луп работает, делая запросы к *event provider* и ожидая их (например, сокет), а затем вызывает необходимый *event handler* (диспатчит ивент. Например, обработчик http запроса).

https://en.wikipedia.org/wiki/Event_loop

Можно представить его так:
```c
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

Новые GUI фреймворки заменили event loop на event dispatch thread (EDT).

Вообще, как связаны здесь GUI приложения и ивенты? Дело в том, что действия юзера - это все какие-то ивенты, и каждое действие пользователя должно вызывать какие-то изменения, их надо как-то обрабатывать. Поэтому event-driven парадигма так популярна в GUI приложениях.

Event loop и EDT - это все об event-driven парадигме программирования.

### Liveness hazards

Для начала, надо разобраться, что такое liveness.

*Liveness* - живучесть приложения, возможность делать какой-то прогресс, даже если конкуррентно выполняющиеся компоненты ожидают вхождения в критическую секцию.

То есть, если safety означает "nothing bad ever happens", то liveness говорит: "something good eventually happens". Liveness failure происходит, когда состояние приложение таково, что оно не может делать даже постепенный прогресс.

Существует разные варианты liveness:
- freedom from deadlock
- freedom from starvation
- freedom from livelock

### Почему вообще баги связанные с конкуррентностью тяжело обнаружимы?

Потому что многое зависит от порядка выполнения операций. Тебе постоянно надо думать, что если A произойдет перед B, произойдет после B и т.д.

## Part 1: Fundamentals

### Chapter 2: Thread Safety
Самое правильное возможное определение thread safety дано именно в данной книге.

- **Thread safety** - класс является thread-safe, если он ведет себя *корректно* когда используется несколькими тредами, в независимости от стратегии шедулинга или порядка операций в тредах, и без дополнительной синхронизации с вызывающей стороны.

Я не зря выделил здесь слово *корректно*: корректность - это соответствие поведения класса дизайну класса, предписанным инвариантам и пост эффектам.

- **Thread safe** класс инкапсулирует необходимую синхронизацию в реализации, так что клиентам не приходится делать синхронизацию при работе с классом.

**Про состояние объекта:**

Что такое Object's state вообще? Object's state - это дата, которая содержится в полях объекта (инстансы и статические поля).

Вообще, thread safety - это именно о состоянии, а не о коде. Мы говорим о thread safety когда смотрим на кусок кода, который инкапсулирует свое состояние, а этот кусок кода может быть объектом или целой программой.

#### Race condition

**Race condition** - это о порядке действий, об их тайминге. Race condition - это возможность некорректного результата когда два треда из-за неудачного тайминга действий могут выдать некорректный результат, сделать что-то плохое. Простой пример - инкремент int или long переменной из двух тредов с помощью операции инкремента `++` без синхронизации.

Кстати, нельзя путать термин race condition с термином *data race*, который означает то, что синхронизация не используется при работе с shared non-final полем. Мы рискуем получить дата рейс, когда пишем в переменную, которая может быть прочитана другим полем, и когда читаем переменную, в которую другой тред мог что-то записать. Дата рейсы будут разобраны позже (Chapter 16). Не все race conditions это data races, и не все data races это race conditions, но часто они могут присутствовать оба. Например, в ситуации с инкрементом есть и race condition, и data race.

Самый популярный вид race condition - это check-then-act. Сначала мы проверяем условие X, далее в зависимости от верности предиката X делаем какое-то действие, но в момент между проверкой и действием условие могло стать невалидным из-за действий другого треда. Таким образом, валидность результат зависит от тайминга действий, т.е. мы имеем race condition.

Где может быть check-then-act race condition? Самый распространенный случай - это lazy initialization (т.е. конструкция вида `if (object == null) object = new Object`).

### Locks

#### Intrinsic Locks

Intrinsic Lock - лок, который построен на основе внутренней сущности класса (какого-то поля или самого объекта, т.е. this).

Пример intrinsic лока в джаве - `synchronized`. Если `synchronized` применено к методу, то для лока используется сам объект (this).

Каждый Java объект может использоваться в качестве лока. Вообще, правильнее сказать, что каждый Java объект имеет intrinsic лок (под него выделяется память когда создается новый объект), и его остается только получить с помощью `synchronized`.

#### Reentrancy

Да, тред не может получить лок, который захвачен другим тредом. Однако, intrinsic лок может быть получен снова тем же тредом, который его захватил. Свойство получить лок, который уже захвачен тем же тредом, называется **reentrancy**.

Reentrancy обозначает, что лок получается на per-thread, а не per-invocation базисе. То есть лок может получить только 1 тред, но и дальнейшее его использование возможно в том же треде.

Reentrancy реализовано так: с каждым локом ассоциируется owner тред и счетчик захватов. Если счетчик равен 0, то лок считается свободным. Когда тред захватывает лок, устанавливается owner thread и счетчик инкрементируется до 1. Когда тот же тред снова захватывает лок, то счетчик опять инкрементируется. Когда тред выходит из synchronized блока кода, счетчик декрементируется. Когда счетчик достигает 0, то лок освобождается.

### Guarding State with Locks

Нельзя думать, что локи нужны только для записи в объект - даже чтение должно производиться через этот лок. Мы узнаем, почему это так, в Chapter 3.

Более того, если объект может быть использован несколькими тредами, то все доступы к этому объекту должны быть обеспечиваться **одним и тем же локом**. В таком случае, мы говорим, что объект guarded by this lock. Когда класс имеет инвариант, который включает в себя больше одной переменной (то есть инвариант накладывает связывает как-то эти переменные), то все эти переменные также должны быть защищены (guarded) одним и тем же локом. Это позволяет нам изменять их в единой атомарной операции, сохраняя инвариант.

Также, каждая изменяемая shared переменная должна быть защищена **только одним локом**. То есть все действия с ней должны делаться только через один лок.

### Liveness and Performance

Один совет: исключать long-running операции (это или compute-intensive или I/O blocking операции) из синхронизированных блоков кода и оставлять в таких блоках только действия, относящиеся к mutual состоянию объекта. Таким образом, мы можем не сильно замедлять производительность.
