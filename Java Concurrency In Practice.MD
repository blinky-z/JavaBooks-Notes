# Java Concurrency In Practice, Brian Goetz

### Chapter 1: Introduction

### Что такое event loop (общее понятие)?

**Event loop (цикл событий)** - это луп, который ожидает новых ивентов, а далее передает ивент в обработчик ивента. Ивент луп работает, делая запросы к *event provider* и ожидая их (например, сокет), а затем вызывает необходимый *event handler* (диспатчит ивент. Например, обработчик http запроса).

https://en.wikipedia.org/wiki/Event_loop

Можно представить его так:
```c
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

Новые GUI фреймворки заменили event loop на event dispatch thread (EDT).

Вообще, как связаны здесь GUI приложения и ивенты? Дело в том, что действия юзера - это все какие-то ивенты, и каждое действие пользователя должно вызывать какие-то изменения, их надо как-то обрабатывать. Поэтому event-driven парадигма так популярна в GUI приложениях.

Event loop и EDT - это все об event-driven парадигме программирования.

### Liveness hazards

Для начала, надо разобраться, что такое liveness.

*Liveness* - живучесть приложения, возможность делать какой-то прогресс, даже если конкуррентно выполняющиеся компоненты ожидают вхождения в критическую секцию.

То есть, если safety означает "nothing bad ever happens", то liveness говорит: "something good eventually happens". Liveness failure происходит, когда состояние приложение таково, что оно не может делать даже постепенный прогресс.

Существует разные варианты liveness:
- freedom from deadlock
- freedom from starvation
- freedom from livelock

### Почему вообще баги связанные с конкуррентностью тяжело обнаружимы?

Потому что многое зависит от порядка выполнения операций. Тебе постоянно надо думать, что если A произойдет перед B, произойдет после B и т.д.

---

## Part 1: Fundamentals

### Chapter 2: Thread Safety
Самое правильное возможное определение thread safety дано именно в данной книге.

- **Thread safety** - класс является thread-safe, если он ведет себя *корректно* когда используется несколькими тредами, в независимости от стратегии шедулинга или порядка операций в тредах, и без дополнительной синхронизации с вызывающей стороны.

Я не зря выделил здесь слово *корректно*: корректность - это соответствие поведения класса дизайну класса, предписанным инвариантам и пост эффектам.

- **Thread safe** класс инкапсулирует необходимую синхронизацию в реализации, так что клиентам не приходится делать синхронизацию при работе с классом.

**Про состояние объекта:**

Что такое Object's state вообще? Object's state - это дата, которая содержится в полях объекта (инстансы и статические поля).

Вообще, thread safety - это именно о состоянии, а не о коде. Мы говорим о thread safety когда смотрим на кусок кода, который инкапсулирует свое состояние, а этот кусок кода может быть объектом или целой программой.

#### Race condition

**Race condition** - это о порядке действий, об их тайминге. Race condition - это возможность некорректного результата когда два треда из-за неудачного тайминга действий могут выдать некорректный результат, сделать что-то плохое. Простой пример - инкремент int или long переменной из двух тредов с помощью операции инкремента `++` без синхронизации.

Кстати, нельзя путать термин race condition с термином *data race*, который означает то, что синхронизация не используется при работе с shared non-final полем. Мы рискуем получить дата рейс, когда пишем в переменную, которая может быть прочитана другим полем, и когда читаем переменную, в которую другой тред мог что-то записать. Дата рейсы будут разобраны позже (Chapter 16). Не все race conditions это data races, и не все data races это race conditions, но часто они могут присутствовать оба. Например, в ситуации с инкрементом есть и race condition, и data race.

Самый популярный вид race condition - это check-then-act. Сначала мы проверяем условие X, далее в зависимости от верности предиката X делаем какое-то действие, но в момент между проверкой и действием условие могло стать невалидным из-за действий другого треда. Таким образом, валидность результат зависит от тайминга действий, т.е. мы имеем race condition.

Где может быть check-then-act race condition? Самый распространенный случай - это lazy initialization (т.е. конструкция вида `if (object == null) object = new Object`).

### Locks

Локи позволяют обеспечить exclusive access к критической секции. А что такое *критичесская секция*?

**Критическая секция** может являться как shared данными, так и набором операций, которые должны быть выполнены атомарно.

То есть эти 2 утверждения:
1. Локи позволяют обеспечить exclusive access к shared данным
2. Локи нужны, чтобы превратить compound операции, такие как check-then-act и read-modify-write операции в атомарные

полностью покрываются утверждением выше.

#### Intrinsic Locks

Intrinsic Lock - лок, который построен на основе внутренней сущности класса (какого-то поля или самого объекта, т.е. this).

Пример intrinsic лока в джаве - `synchronized`. Если `synchronized` применено к методу, то для лока используется сам объект (this).

Каждый Java объект может использоваться в качестве лока. Вообще, правильнее сказать, что каждый Java объект имеет intrinsic лок (под него выделяется память когда создается новый объект), и его остается только получить с помощью `synchronized`.

#### Reentrancy

Да, тред не может получить лок, который захвачен другим тредом. Однако, intrinsic лок может быть получен снова тем же тредом, который его захватил. Свойство получить лок, который уже захвачен тем же тредом, называется **reentrancy**.

Reentrancy обозначает, что лок получается на per-thread, а не per-invocation базисе. То есть лок может получить только 1 тред, но и дальнейшее его использование возможно в том же треде.

Reentrancy реализовано так: с каждым локом ассоциируется owner тред и счетчик захватов. Если счетчик равен 0, то лок считается свободным. Когда тред захватывает лок, устанавливается owner thread и счетчик инкрементируется до 1. Когда тот же тред снова захватывает лок, то счетчик опять инкрементируется. Когда тред выходит из synchronized блока кода, счетчик декрементируется. Когда счетчик достигает 0, то лок освобождается.

### Guarding State with Locks

Нельзя думать, что локи нужны только для записи в объект - даже чтение должно производиться через этот лок. Это так по следующим причинам:
 1. Если операции записи закрывать в synchronized блок, а операции чтения нет, то операции чтения могут прочитать половинное значение, а мы, используя локи, добиваемся именно атомарности
 2. synchronized должен использоваться для чтения потому, что таким образом обеспечивается, что write happens-before read (стандарт гарантирует это для synchronized) - то есть достигается видимость изменений, осуществленных в write операциях.

Более того, если объект может быть использован несколькими тредами, то все доступы к этому объекту должны быть обеспечиваться **одним и тем же локом**. В таком случае, мы говорим, что объект guarded by this lock. Когда класс имеет инвариант, который включает в себя больше одной переменной (то есть инвариант накладывает связывает как-то эти переменные), то все эти переменные также должны быть защищены (guarded) одним и тем же локом. Это позволяет нам изменять их в единой атомарной операции, сохраняя инвариант.

Также, каждая изменяемая shared переменная должна быть защищена **только одним локом**. То есть все действия с ней должны делаться только через один лок.

### Liveness and Performance

Один совет: исключать long-running операции (это или compute-intensive или I/O blocking операции) из синхронизированных блоков кода и оставлять в таких блоках только действия, относящиеся к mutual состоянию объекта. Таким образом, мы можем не сильно замедлять производительность.

--

## Chapter 3: Sharing Objects

Мы видели, как synchronized блоки кода могут обеспечить эксклюзивный доступ к критической секции, но не стоит думать, что `synchronized` используется только для этого. В многопоточном мире есть такое понятие, как **memory visibility** - видимость изменений одного треда в других тредах. Мы хотим не только избежать race condition, но и сделать так, чтобы изменения были видимы для других тредов.

Synchronized гарантирует happens-before отношение для любого последующего вызова synchronized на том же объекте (именно на объекте, не важно какой intrinsic лок используется), то есть все действия в первом synchronized блоке произошли гарантированно перед следующим вызовом synchronized метода (а как мы знаем, JVM может менять порядок операций, поэтому это важно).

### 3.1. Visibility

Видимость вообще уточенная штука. Дело в том, что изменения одного треда могут быть не видны другим тредам вообще никогда или же порядок операций может меняться.

Вот пример:
```java
public class NoVisibility {
    private static boolean ready;
    private static int number;
    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready) Thread.yield();
            System.out.println(number);
        }
    }
    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```

Здесь может произойти 2 вещи:
1. Запись в ready может быть не видна ожидающему треду никогда - здесь проблема видимости
2. Запись в ready произойдет до записи в number, и станет видна ожидающему треду, тогда ожидающий тред выведет 0, т.е. дефолтное значение int, но здесь могло быть null в случае объекта. В любом случае, в более сложном кейсе дальнейшая работа с неустановленным значением привела бы к неправильному результату - здесь проблема reordering операций

Reordering может быть не только в JVM, но и в компиляторе и процессоре. Мы не должны ничего предпологать о порядке операций, и полагаться на это при разработке конкуррентных программ. Если же happens before гарантируется стандартом, только тогда мы можем быть уверены что одни операции выполнятся перед другими.

Простой способ избежать этого - использовать синхронизацию при доступе к shared данным.

#### 3.1.2. Non-atomic 64 bit операции

JMM гарантирует, что store и read операции атомарны для всех типов объектов, за исключением long и double, которые не объявлены как volatile или не защищены локом. Тогда есть опасность того, что при записи одним тредов в long или double переменную другой тред увидит половинное значение: 32 бита одной совершенной операции, и 32 бита от прошлого значения, т.е. получит некорректное значение.

#### 3.1.3. Locking and Visibility

Тут говорится о том, что синхронизация должна использоваться и для visibility, а не только для mutual exclusion тредов.

Конкретно здесь говорится о чем я уже говорил: 
> Synchronized гарантирует happens-before отношение для любого последующего вызова synchronized на том же объекте (именно на объекте, не важно какой intrinsic лок используется), то есть все действия в первом synchronized блоке произошли гарантированно перед следующим вызовом synchronized метода (а как мы знаем, JVM может менять порядок операций, поэтому это важно).

#### 3.1.4. Volatile variables

Джава предлагает более слабую альтернативу синхронизации, но более производительную - **volatile**. Volatile гарантирует следующие вещи:

1. Операции с переменной, объявленной как volatile, не будут reordered и порядок для них сохранится, как в коде
2. Значения не будут кэшированы и чтение всегда получит самое последнее опубликованное значение

На самом деле, эффекты видимости volatile переменной выходят за пределы самой volatile переменной. Дело в том, что когда тред A пишет в volatile переменную и тред B последовательно читает ее значение, значения переменных, которые были видны треду A до записи в volatile переменную, становятся видны и треду B после чтения volatile переменной. То есть, о volatile можно думать так: запись в volatile - это выход из synchronized блока, а чтение из volatile - это вход в synchronized блок. Однако, не стоит сильно полагаться на это. Гораздо лучше использовать volatile только для первых 2 гарантированных вещей, а не таких эффектов видимости. Такой код опасен и сложнее понятен.

Таким образом, следует использовать *volatile* только тогда, когда они упрощают разработку политики синхронизации. Не следует их использовать, когда проверка корректности требовала бы думать о видимости других состояний. То есть, использовать volatile стоит, когда оно включает в себя только состояние самой volatile переменной.

Volatile можно использовать только тогда, когда в переменную пишет всегда только 1 тред, а другие только читают. Тогда read-modify-write операции на ней безопасны. Почему это так? Потому что TODO: узнать почему так

Самый распространненый случай volatile - это completion, interruption или status flag.

Локинг гарантирует нам как visibility, так и atomicity, а volatile - только visibility. Поэтому, например, операция инкремента на volatile переменной не является атомарной до тех пор, пока мы не можем гарантировать, что в переменную пишет всегда только 1 тред (увеличивает счетчик только 1 тред). Тогда не будет конкурретности записи и другие треды не смогут увидеть значение до modify-write шага и установить то же значение, что и первый тред.

Вообще, отвлекусь. Что такое атомарная операция инкремента? Атомарная операция инкремента должна увеличивать счетчик за 1 шаг (а не 3: read-modify-write). Поэтому в ней используется cas-луп или мьютекст для того, чтобы гарантировать, что операция инкремента действительно заняла 1 шаг. Что по сути означает 1 шаг? Это означает как бы, что это одна инструкция, а если cas возвращает false, то значит что в нашу инструкцию кто-то вмешался, и это был нифига не 1 шаг. Чтобы выглядело все как 1 шаг, все шаги read-modify-write должны выполниться сразу без конкурренции.

Итак, использовать volatile можно только тогда, когда выполнены следующие условия:
- Запись в volatile переменную не зависит от её текущего значения, или мы можем гарантировать, что в переменную пишет всегда только 1 тред
- Переменная не участвует вместе с другими переменными в инварианте (так как для поддержания инварианта нам требуется атомарность, то есть обновлять переменные, участвующие в инварианте, требуется атомарно)
- Локинг не требуется при доступе к переменной

### 3.2. Publication and Escape

**Публикация объекта** - это делание его видимым в коде вне текущего scope, такое как сохранение ссылки на объект где другой код может получить эту ссылку, возвращая объект из non-private метода или передавая объект в метод другого класса. Заметь, здесь нет ничего про многопоточность.

Во одних ситуациях мы хотим чтобы инкапсуляция не нарушалась и объект не был запаблишен. В других ситуациях мы хотим публикации объекта, однако делание этого thread-safe образом может потребовать некоторой синхронизации.

Ситуация, когда объект был запаблишен когда он не должен был называется **escape**, и говорится, что *object escaped.*
Стоит понимать, что если какой-нибудь объект доступен из запаблишенного объекта, то и он становится неявно запаблишенным. Например, запаблишенный массив объектов предоставляет доступ к элементам самого массива.

Далее мы рассмотрим, как объект может быть escaped.

1. Объявить поле как `public static`, так что любой класс или тред может получить к нему доступ

2. Предоставить getter для private поля

3. Передать объект в *alien метод*. С перспективы класса C, для него alien метод тот, спецификация и поведение которого не определяется самим классом C. Это включает методы других классов, а также overrideable методы (ни private ни final) самого класса C. Передача объекта в alien метода считается публикацией объекта, так как мы не знаем, что этот метод будет делать с объектом, т.к. мы его не контролируем. Alien метод может запаблишить объект или сохранить ссылку на него, так что другой тред в будущем заиспользует эту ссылку. Не важно, что делает именно другой тред. Всегда есть риск, что другой класс или тред могут злоупотребить, явно или неявно, объектом.

4. Публикация this ссылки. Это делается через публикацию inner class instance (inner class - это non-static nested класс), а как мы знаем, inner класс содержит скрытую ссылку на enclosing instance. Из стандарта: `Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private. Static nested classes do not have access to other members of the enclosing class`. Пример:
```java
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(
            new EventListener() {
                public void onEvent(Event e) {
                    doSomething(e);
                }
            });
    }
}
```

Мы паблишим EventListener, а он содержит скрытую ссылку на ThisEscape, через которую можно получить все поля enclosing класса, даже private. Сам же enclosing объект можно получить через выражение `ThisEscape.this`.

#### 3.2.1. Safe Construction Practices

Прошлый пример показал, как this reference может утечь во время конструкции объекта (т.е. во время работы конструктора). Это очень опасно, так как такой объект, конструктор которого еще не завершился, но ссылка на который утекла, считается не до конца сконструированным, находится в неконсистентном состоянии. Это правда, даже если публикация - это последнее выражение в конструкторе (смотри прошлый пример - там публикация это единственное выражение в конструкторе ThisEscape).

Два примера, как ссылка может утечь во время конструкции объекта:
1. Запуск треда из конструктора. Тогда запущенный тред сможет получить доступ к полям еще не завершившего конструкцию объекта, так как класс Thread будет считаться inner классом (а конкретно, anonymous классом). Здесь говорится именно о запуске треда, а не о конструкции. Лучший способ избежать этого - предоставить отдельный метод для запуска треда, а конструировать тред в конструкторе.
2. Вызов overrideable instance метода из конструктора (private и final методы не считаются). Тогда методы того же класса также могут получить достук к полям еще не завершившего конструкцию объекта.
3. Вызов метода другого класса с передачей this ссылки

Мы не можем избежать публикации скрытой this ссылки на enclosing класс, так как так работает сама джава, однако мы должны избегать её публикации во время работы конструктора.

### 3.3. Thread Confinement

Thread Confinement - ограничение свободы тредов, ограничение дозволенности тредов.

Доступ shared mutable данных требует синхронизации. Один путь избежать этого требования - не шарить данные. Если данные доступны только из одного треда, то синхронизация не понадобится. Эта техника называется **Thread Confinement**. Если объект confined к треду, то такое использование объекта безопасно, даже если сам объект не является безопасным.

Swing использует эту технику: Swing visual components и data model объекты не безопасны сами по себе; вместо этого, они confined к Event Dispatch треду. Другие треды для правильного функционирования приложения не должны трогать эти объекты. Для того, чтобы обновить эти объекты из других тредов, эти треды должны попросить Event Dispatch Thread обновить эти объекты - это делается через `invokeLater` механизм, который шедулит Runnable для исполнения в event dispatch треде).

Также эта техника используется в pooled JDBC. JDBC спецификация не требует от объектов `Connection` быть thread-safe, но вместо этого тред получает Connection из пула коннекшенов, использует его для синхронного обслуживания запроса в одном треде, и возвращает обратно в пул. В это время пул не дает тот же Connection другим тредам, пока он не вернулся. Такой паттерн неявно привязывает (confines) Connection объект к единственному треду.

Так как в джаве нет механизма для гарантирования Thread Confinement, то правильное использование этой техники должно принуждаться только самой имплементацией приложения. Джава и библиотеки предоставляют механизмы, которые могут помочь в обеспечении правильности использования этой техники - например, локальные переменные или ThreadLocal класс, но все равно, гарантирование, что объект не покинет тред, зависит от программиста.

#### 3.3.1. Ad-hoc Thread Confinement

Ad-hoc - when necessary or needed, то есть использование только в случае нужды

Пример использования:
> an ad hoc committee/meeting

>> We deal with problems on an ad hoc basis (= as they happen).

Здесь говорится про то, что необходимость (то есть ad-hoc) Thread Confinement появляется только в последствии решения сделать систему single-threaded. Однако, Thread confinement крайней fragile, потому что правильное использование техники ложится только на программиста, и джава не сильно помогает в этом.

Да, иногда, single-threaded система имеет больше плюсов, чем имеет минусов Thread Confinement. Такзже специальный кейс Thread Confinement - легкость использования volatile переменных. Как мы помним, это безопасно использовать read-mofidy-write операции на volatile переменной до тех пор, пока в нее пишет только 1 тред, а Thread Confinement дает нам как раз это.

Существует две наиболее сильные формы Thread Confinement
* Stack Confinement (#3.3.2), где переменные хранятся только в локальных переменных. то есть в стеке одного треда, а его стек не доступен из других тредов. Также это называется within-thread или thread-local confinement (не путать с классом ThreadLocal в джаве, следующий пункт)
* ThreadLocal Confinement (#3.3.3) - переменные хранятся в ThreadLocal объектах. Глобальный ThreadLocal объект возвращает каждому треду отдельную копию объекта, хранящегося в ThreadLocal объекте. Пример использования:

```java
public class ThreadLocalExample {
    private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
        public Connection initialValue() {
            return DriverManager.getConnection(DB_URL);
        }
    };
    public static Connection getConnection() {
        return connectionHolder.get();
    }
}
```

### 3.4. Immutability

Другой способ избежать синхронизации - это использование immutable объектов (только реально immutable! об этом писалось в Effective Java, иммутабельность надо очень хорошо проверять).

Вообще, все проблемы с обозреванием объекта в неконсистентом состоянии, обозреванием stale (non-recent) значений, не видимостью обновлений, происходят из того, что несколько тредов пытаются обновлять mutable состояние объекта.

Иммутабельные объекты от природы thread-safe: их инварианты устанавливаются конструктором, а так как состояние такого объекта нельзя изменить, то и инварианты сохраняются всегда. Ясно, что иммутабельные объекты можно не боясь шарить и паблишить.

Глобальные иммутабельные объекты часто следует использовать вместе с volatile для паблиша обновления состояния immutable объекта (обновление состояния происходит через замену старого immutable объекта на новый инстанс immutable объекта). Использование immutable объекта + volatile позволяет классу позволяет быть thread-safe, избегая explicit локов.

### 3.5. Safe Publication

В данной главе мы обсудим, как правильно паблишить объекты. Ясно, что сохранения объекта в public поле или предоставления геттера не достаточно.

Вообще, из-за неправильной публикации может быть 2 плохие вещи:
1. Другие треды могут увидеть старое значение для переменной, а это или null или старое значение
2. Другие треды могут увидеть up to date значение для ссылки на переменную, но stale состояние переменной

Последний кейс особенно прикольный. Дело в том, что конструктор `Object` сначала устанавливает значения по-умолчанию для всех полей, и только затем вызывается сабконструктор (как мы помним, все классы наследуются неявно от Object в джаве). Так вот, хоть и ссылка может обнаружиться up-to-date, но внутренние поля класса не гарантируются быть обнаруженными тоже up-to-date. TODO: узнать правда ли это так?

Вот пример такого класса:
```java
public class Holder {
    private int n;
    public Holder(int n) {
        this.n = n;
    }
    public void assertSanity() {
        if (n != n) throw new AssertionError("This statement is false.");
    }
}
```

При неправильной публикации здесь проверка может запросто упасть из-за того, что при первом чтении было обнаружено default значение, а при втором чтении - внутреннее поле `n` стало up-to-date тоже, просто с запозданием.

#### 3.5.2. Immutable Objects and Initialization Safety

Так как immutable объекты крайне важны вообще в мире программирования, то в JMM для них существют специальные гарантии.

Как мы видели ранее, обнаружение up to date ссылки на объект еще не гарантирует, что и состояние объекта будет тоже up to date. Чтобы гарантировать консистентное состояние объекта, требуется синхронизация.

Иммутабельные объекты, в свою очередь, могут быть безопасно просматриваться, даже если синхронизация не использовалась при публикации. Для этого все поля класса должны быть `final`. Джава гарантирует, что в `final` полях всегда будет up-to-date значение. Однако, если по final полю находится mutable объект, синхронизация, конечно же, все еще требуется.

#### 3.5.3. Safe Publication Idioms

Здесь описываются правила безопасной публикации только что сконструированного объекта. О видимости изменений, сделанных после публикации, мы поговорим позже. Да, данные вещи стоит разделять.

Чтобы опубликовать объект безопасно, оба, и ссылка, и состояние объекта должны быть видимы другим тредам в одно и то же время. Правильно сконструированный объект может быть безопасно опубликован с помощью:
- Инициализация ссылки на объект из *static initializer* (`public static Holder holder = new Holder(42);`)
- Храня ссылку на объект в *volatile* или *AtomicReference* поле
- Храня ссылка на объект в *final* поле
- Храня ссылка на объект в поле, которое защищено локом (guarded by lock)

#### 3.5.4. Effectively Immutable Objects

При правильной конструкции объекта, все safe publication механизмы, описанные выше, гарантируют, что состояние будет консистентным как только ссылка на объект становится видной. И если состояние не собирается изменяться в дальнейшем, то этого достаточно для безопасного использования объекта без какой-то синхронизации.

Такие объекты, которые не являются иммутабельными, но чье состояние не будет изменено после публикации, называются **effectively immutable**. Использование таких объектов может облегчить разработку, но в то же время повышает вероятность ошибок, и с ними следует обходиться осторожно.

#### 3.5.5. Mutable Objects

Если же объект собирается быть измененным в дальнейшем, то должна использоваться синхронизция не только для публикации изменений, но и при доступе к объекту для видимости изменений.

Таким образом, чтобы шарить mutable объекты безопасно, они должны быть безопасно опубликованы и должны быть thread-safe или защищены локом.

Подведем итог безопасной публикации объектов. Как объект должен быть опубликован, зависит от его изменяемости:
- **Immutable** - может быть опубликован любым способом
- **Effectively immutable** - должен быть безопасно опубликован (одним из способов, описанных выше)
- **Mutable** - должен быть безопасно опубликован (одним из способов, описанных выше), а также должен быть thread-safe или защищен локом

Напомню, thread-safe объект делает всю синхронизацию внутренне и может использоваться без дополнительной синхронизации. Мы говорим, "защищен локом", если для работы с объектом исползуется дополнительная синхронизация.

---

## Chapter 4: Composing Objects

До этого момента мы фокусировались на low-level аспектах thread safety и синхронизации. Но мы не хотим анализировать каждый кусочек доступа к памяти: мы хотим брать thread-safe компоненты и безопасно компоновать их в бОльшие компоненты и программы. В этой главе описываются паттерны конструирования классов, которые помогут сделать их thread-safe и случайно не нарушить их thread safety гарантии.

### 4.1. Designing a Thread-safe Class

Процесс дизайна thread-safe классов должен выключать следующие 3 базовых элемента:
- Определить переменные, которые формируют состояние объекта
- Определить инварианты, которые ограничивают переменные-состояния
- Установить политику конкуррентного доступа к состоянию объекта

Если объект A содержит поле-ссылку на другой объект B, в котором также существуют переменные-состояния, то и эти поля входят в состав состояния объекта A. Например, состояние LinkedList включает в себя состояния всех nodes принадлежащих листу.

Что такое политика синхронизации (synchronization policy)? **Политика синхронизации** определяет, как объект координирует доступ к своему состоянию без нарушения своих инвариантов и post-conditions (пост-эффектов). Политика синхронизации задает комбинацию иммутабельности, thread confinement, локинга для поддержания thread safety, а также говорит, какими локами защищены переменные. Чтобы анализировать и поддерживать класс более легко, всегда документируйте политику синхронизации.

#### 4.1.1. Gathering Synchronization Requirement

Делание класса thread-safe обозначает поддержание его инвариантов под конкуррентным доступом, а это требует думать о состоянии объекта.

Переменные и объекты имеют **пространство состояний**: диапазон возможных состояний, которые может принимать переменная/объект.

Аналогично, операции могут иметь **post-conditions**, которые определяют некоторые state transitions как невалидные. Например, если состояние счетчика 17, то следующее валидное его состояние - только 18. 

Здесь замечу: если следующее состояние наследуется (зависит) от предыдущего состояния, то операция считается compound операцией - а такая операция должна быть обязательно атомарной. Однако, не все операции имеют ограничения на state transitions. Например, если обновлять показания температуры, то новое состояние не зависит от прошлого.

Ограничения, наложенные на состояния или стейт транзишены инвариантами и пост-эффектами, требуют дополнительной синхронизации или инкапсуляции. Если какое-то состояние считается невалидное, или переменная имеет невалидные переходы, то состояние необходимо инкапсулировать, не позволяя клиенту класса перевести объект в невалидное состояние.

Класс также может иметь ограничения, включающие несколько переменных. Как я уже говорил, такие переменные должны обновляться в одной атомарной операции. Нельзя обновить одну переменную, а затем другую как отдельную операцию - так возникает окно, во время которого инвариант нарушается, а значит класс находится в невалидном состоянии.

Итак, выделю самую важную мысль: мы не можем убедиться в thread safety класса до тех пор, пока не определим инварианты и пост-эффекты. Именно ограничения на валидные значения и валидные переходы состояний создают требования атомарности и синхронизации.

#### 4.1.2. State-dependent Operations

Инварианты класса и post-conditions метода ограничивают валидные состояния и переходы состояний. Однако, некоторые методы классов имеют также state-based preconditions. Например, мы не можем удалить элемент из пустой очереди. Такие операции с state-based preconditions называются state-dependent. 

В single-threaded системе такая операция, если не выполняется precondition, имеет только единственный выбор упасть с исключением. Но в конкуррентной среде это preconditions может выполниться, но только позже, из-за действий другого треда. Поэтому конкуррентные программы добавляют возможность ожидания выполнения preconditions, и последующего выполнения state-dependent операции на валидном состоянии.

Build-in механизмы для ожидания (wait и notify) крайне сильно привязаны к intrinsic локингу (так как wait и notify работают на самом объекте), поэтому не рекомендуется использовать их. Для написания методов, которые могут ожидать выполнения preconditions, лучше следует использовать существующие стандартные библиотеки, например, такие классы как BlockingQueue и Semaphore.

## 4.2. Instance Confinement

Если объект сам по себе не является thread-safe, то мы все еще можем гарантировать безопасный доступ к нему: через Thread Confinement или же защитив его локом.

Instance Confinement - это об заключении объекта в другой объект, таким образом ограничивая пути доступа к объекту до путей доступа до enclosing объекта, и более того, до методов enclosing объекта, вместо того, чтобы предоставлять доступ из всей программы, а также это позволяет нам гарантировать то, что доступ к объету происходит через правильный лок.

Confined объекты не должны сбегать из их договоренной области видимости. Как объекты могут сбегать, мы уже обсуждали раннее (Publication and Escape).

Объект может быть confined to (заключен в):
- class instance (например, приватное поле)
- lexical scope (например, локальная переменная)
- thread (например, объект передается из метода в метод, но в одном треде)

Instance Confinement (также называемый просто как Confinement) - наиболее простой способ обеспечить thread safe доступ к объекту. Также это предоставляет гибкость в выборе стратегии локинга, так как мы даем только API enclosing класса, а как оно устроено внутри - не важно.

Есть много примеров confinement'а в стандартных библиотеках. Например, factory метод `Collections.synchronizedList` и другие заключают внутри себя List и предоставляют синхронизированное API, которое делегирует запросы к коллекции внутри. Такие factory методы используют паттерн Декоратор - просто оборачивают объект для превращения non thread-safe объекта в thread safe. Однако, здесь важно заметить то, что право ownership передается теперь wrapper объекту, и нижележащую коллекцию следует использовать только через wrapper объект, иначе thread safety нарушится.

### 4.2.1. The Java Monitor Pattern

Instance Confinement логически подводит нас к паттерну Монитор. Класс, следующий этому паттерну, инкапсулирует все свои изменяемые (mutable) состояния и зищащет их intrinsic локами.

Хоть данный патерн и не позволяет предоставить fine-grained политику синхронизации, но этот паттерн явялется наиболее простым способом синхронизации.

Стоит заметить, что для защиты состояний лучше следует использовать внутренний приватный лок, а не сам объект или какой-то другой публичный лок объекта, иначе клиент может вмешиваться в политику синхронизации, и явно или неявно может помешать синхронизации, используя сам объект или публичный лок объекта как intrinsic лок. Классы, которые неправильно используют публично открытый лок другого класса, могут вызвать liveness проблемы. Также открытость лока заставляет нас проверять всю программу, а не только единичный класс, для гарантии того, что лок используется верным способом и сам класс является thread safe.

## 4.3. Delegating Thread Safety

