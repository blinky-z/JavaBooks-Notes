# Java Concurrency In Practice, Brian Goetz

### Chapter 1: Introduction

### Что такое event loop (общее понятие)?

**Event loop (цикл событий)** - это луп, который ожидает новых ивентов, а далее передает ивент в обработчик ивента. Ивент луп работает, делая запросы к *event provider* и ожидая их (например, сокет), а затем вызывает необходимый *event handler* (диспатчит ивент. Например, обработчик http запроса).

https://en.wikipedia.org/wiki/Event_loop

Можно представить его так:
```c
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

Новые GUI фреймворки заменили event loop на event dispatch thread (EDT).

Вообще, как связаны здесь GUI приложения и ивенты? Дело в том, что действия юзера - это все какие-то ивенты, и каждое действие пользователя должно вызывать какие-то изменения, их надо как-то обрабатывать. Поэтому event-driven парадигма так популярна в GUI приложениях.

Event loop и EDT - это все об event-driven парадигме программирования.

### Liveness hazards

Для начала, надо разобраться, что такое liveness.

*Liveness* - живучесть приложения, возможность делать какой-то прогресс, даже если конкуррентно выполняющиеся компоненты ожидают вхождения в критическую секцию.

То есть, если safety означает "nothing bad ever happens", то liveness говорит: "something good eventually happens". Liveness failure происходит, когда состояние приложение таково, что оно не может делать даже постепенный прогресс.

Существует разные варианты liveness:
- freedom from deadlock
- freedom from starvation
- freedom from livelock

### Почему вообще баги связанные с конкуррентностью тяжело обнаружимы?

Потому что многое зависит от порядка выполнения операций. Тебе постоянно надо думать, что если A произойдет перед B, произойдет после B и т.д.

---

## Part 1: Fundamentals

### Chapter 2: Thread Safety
Самое правильное возможное определение thread safety дано именно в данной книге.

- **Thread safety** - класс является thread-safe, если он ведет себя *корректно* когда используется несколькими тредами, в независимости от стратегии шедулинга или порядка операций в тредах, и без дополнительной синхронизации с вызывающей стороны.

Я не зря выделил здесь слово *корректно*: корректность - это соответствие поведения класса дизайну класса, предписанным инвариантам и пост эффектам.

- **Thread safe** класс инкапсулирует необходимую синхронизацию в реализации, так что клиентам не приходится делать синхронизацию при работе с классом.

**Про состояние объекта:**

Что такое Object's state вообще? Object's state - это дата, которая содержится в полях объекта (инстансы и статические поля).

Вообще, thread safety - это именно о состоянии, а не о коде. Мы говорим о thread safety когда смотрим на кусок кода, который инкапсулирует свое состояние, а этот кусок кода может быть объектом или целой программой.

#### Race condition

**Race condition** - это о порядке действий, об их тайминге. Race condition - это возможность некорректного результата когда два треда из-за неудачного тайминга действий могут выдать некорректный результат, сделать что-то плохое. Простой пример - инкремент int или long переменной из двух тредов с помощью операции инкремента `++` без синхронизации.

Кстати, нельзя путать термин race condition с термином *data race*, который означает то, что синхронизация не используется при работе с shared non-final полем. Мы рискуем получить дата рейс, когда пишем в переменную, которая может быть прочитана другим полем, и когда читаем переменную, в которую другой тред мог что-то записать. Дата рейсы будут разобраны позже (Chapter 16). Не все race conditions это data races, и не все data races это race conditions, но часто они могут присутствовать оба. Например, в ситуации с инкрементом есть и race condition, и data race.

Самый популярный вид race condition - это check-then-act. Сначала мы проверяем условие X, далее в зависимости от верности предиката X делаем какое-то действие, но в момент между проверкой и действием условие могло стать невалидным из-за действий другого треда. Таким образом, валидность результат зависит от тайминга действий, т.е. мы имеем race condition.

Где может быть check-then-act race condition? Самый распространенный случай - это lazy initialization (т.е. конструкция вида `if (object == null) object = new Object`).

### Locks

Локи позволяют обеспечить exclusive access к критической секции. А что такое *критичесская секция*?

**Критическая секция** может являться как shared данными, так и набором операций, которые должны быть выполнены атомарно.

То есть эти 2 утверждения:
1. Локи позволяют обеспечить exclusive access к shared данным
2. Локи нужны, чтобы превратить compound операции, такие как check-then-act и read-modify-write операции в атомарные

полностью покрываются утверждением выше.

#### Intrinsic Locks

Intrinsic Lock - лок, который построен на основе внутренней сущности класса (какого-то поля или самого объекта, т.е. this).

Пример intrinsic лока в джаве - `synchronized`. Если `synchronized` применено к методу, то для лока используется сам объект (this).

Каждый Java объект может использоваться в качестве лока. Вообще, правильнее сказать, что каждый Java объект имеет intrinsic лок (под него выделяется память когда создается новый объект), и его остается только получить с помощью `synchronized`.

#### Reentrancy

Да, тред не может получить лок, который захвачен другим тредом. Однако, intrinsic лок может быть получен снова тем же тредом, который его захватил. Свойство получить лок, который уже захвачен тем же тредом, называется **reentrancy**.

Reentrancy обозначает, что лок получается на per-thread, а не per-invocation базисе. То есть лок может получить только 1 тред, но и дальнейшее его использование возможно в том же треде.

Reentrancy реализовано так: с каждым локом ассоциируется owner тред и счетчик захватов. Если счетчик равен 0, то лок считается свободным. Когда тред захватывает лок, устанавливается owner thread и счетчик инкрементируется до 1. Когда тот же тред снова захватывает лок, то счетчик опять инкрементируется. Когда тред выходит из synchronized блока кода, счетчик декрементируется. Когда счетчик достигает 0, то лок освобождается.

### Guarding State with Locks

Нельзя думать, что локи нужны только для записи в объект - даже чтение должно производиться через этот лок. Это так по следующим причинам:
 1. Если операции записи закрывать в synchronized блок, а операции чтения нет, то операции чтения могут прочитать половинное значение, а мы, используя локи, добиваемся именно атомарности
 2. synchronized должен использоваться для чтения потому, что таким образом обеспечивается, что write happens-before read (стандарт гарантирует это для synchronized) - то есть достигается видимость изменений, осуществленных в write операциях.

Более того, если объект может быть использован несколькими тредами, то все доступы к этому объекту должны быть обеспечиваться **одним и тем же локом**. В таком случае, мы говорим, что объект guarded by this lock. Когда класс имеет инвариант, который включает в себя больше одной переменной (то есть инвариант накладывает связывает как-то эти переменные), то все эти переменные также должны быть защищены (guarded) одним и тем же локом. Это позволяет нам изменять их в единой атомарной операции, сохраняя инвариант.

Также, каждая изменяемая shared переменная должна быть защищена **только одним локом**. То есть все действия с ней должны делаться только через один лок.

### Liveness and Performance

Один совет: исключать long-running операции (это или compute-intensive или I/O blocking операции) из синхронизированных блоков кода и оставлять в таких блоках только действия, относящиеся к mutual состоянию объекта. Таким образом, мы можем не сильно замедлять производительность.

--

## Chapter 3: Sharing Objects

Мы видели, как synchronized блоки кода могут обеспечить эксклюзивный доступ к критической секции, но не стоит думать, что `synchronized` используется только для этого. В многопоточном мире есть такое понятие, как **memory visibility** - видимость изменений одного треда в других тредах. Мы хотим не только избежать race condition, но и сделать так, чтобы изменения были видимы для других тредов.

Synchronized гарантирует happens-before отношение для любого последующего вызова synchronized на том же объекте (именно на объекте, не важно какой intrinsic лок используется), то есть все действия в первом synchronized блоке произошли гарантированно перед следующим вызовом synchronized метода (а как мы знаем, JVM может менять порядок операций, поэтому это важно).

### Visibility

Видимость вообще уточенная штука. Дело в том, что изменения одного треда могут быть не видны другим тредам вообще никогда или же порядок операций может меняться.

Вот пример:
```java
public class NoVisibility {
    private static boolean ready;
    private static int number;
    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready) Thread.yield();
            System.out.println(number);
        }
    }
    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```

Здесь может произойти 2 вещи:
1. Запись в ready может быть не видна ожидающему треду никогда - здесь проблема видимости
2. Запись в ready произойдет до записи в number, и станет видна ожидающему треду, тогда ожидающий тред выведет 0, т.е. дефолтное значение int, но здесь могло быть null в случае объекта. В любом случае, в более сложном кейсе дальнейшая работа с неустановленным значением привела бы к неправильному результату - здесь проблема reordering операций

Reordering может быть не только в JVM, но и в компиляторе и процессоре. Мы не должны ничего предпологать о порядке операций, и полагаться на это при разработке конкуррентных программ. Если же happens before гарантируется стандартом, только тогда мы можем быть уверены что одни операции выполнятся перед другими.

Простой способ избежать этого - использовать синхронизацию при доступе к shared данным.

#### 3.1.2 Non-atomic 64 bit операции

JMM гарантирует, что store и read операции атомарны для всех типов объектов, за исключением long и double, которые не объявлены как volatile или не защищены локом. Тогда есть опасность того, что при записи одним тредов в long или double переменную другой тред увидит половинное значение: 32 бита одной совершенной операции, и 32 бита от прошлого значения, т.е. получит некорректное значение.

#### 3.1.3 Locking and Visibility

Тут говорится о том, что синхронизация должна использоваться и для visibility, а не только для mutual exclusion тредов.

Конкретно здесь говорится о чем я уже говорил: 
> Synchronized гарантирует happens-before отношение для любого последующего вызова synchronized на том же объекте (именно на объекте, не важно какой intrinsic лок используется), то есть все действия в первом synchronized блоке произошли гарантированно перед следующим вызовом synchronized метода (а как мы знаем, JVM может менять порядок операций, поэтому это важно).

#### 3.1.4 Volatile variables

Джава предлагает более слабую альтернативу синхронизации, но более производительную - **volatile**. Volatile гарантирует следующие вещи:

1. Операции с переменной, объявленной как volatile, не будут reordered и порядок для них сохранится, как в коде
2. Значения не будут кэшированы и чтение всегда получит самое последнее опубликованное значение

На самом деле, эффекты видимости volatile переменной выходят за пределы самой volatile переменной. Дело в том, что когда тред A пишет в volatile переменную и тред B последовательно читает ее значение, значения переменных, которые были видны треду A до записи в volatile переменную, становятся видны и треду B после чтения volatile переменной. То есть, о volatile можно думать так: запись в volatile - это выход из synchronized блока, а чтение из volatile - это вход в synchronized блок. Однако, не стоит сильно полагаться на это. Гораздо лучше использовать volatile только для первых 2 гарантированных вещей, а не таких эффектов видимости. Такой код опасен и сложнее понятен.

Таким образом, следует использовать *volatile* только тогда, когда они упрощают разработку политики синхронизации. Не следует их использовать, когда проверка корректности требовала бы думать о видимости других состояний. То есть, использовать volatile стоит, когда оно включает в себя только состояние самой volatile переменной.

Volatile можно использовать только тогда, когда в переменную пишет всегда только 1 тред, а другие только читают. Тогда read-modify-write операции на ней безопасны.

Самый распространненый случай volatile - это completion, interruption или status flag.

Локинг гарантирует нам как visibility, так и atomicity, а volatile - только visibility.

### 3.2 Publication and Escape

**Публикация объекта** - это делание его видимым в коде вне текущего scope, такое как сохранение ссылки на объект где другой код может получить эту ссылку, возвращая объект из non-private метода или передавая объект в метод другого класса. Заметь, здесь нет ничего про многопоточность.

Во одних ситуациях мы хотим чтобы инкапсуляция не нарушалась и объект не был запаблишен. В других ситуациях мы хотим публикации объекта, однако делание этого thread-safe образом может потребовать некоторой синхронизации.

Ситуация, когда объект был запаблишен когда он не должен был называется **escape**, и говорится, что *object escaped.*
Стоит понимать, что если какой-нибудь объект доступен из запаблишенного объекта, то и он становится неявно запаблишенным. Например, запаблишенный массив объектов предоставляет доступ к элементам самого массива.

Далее мы рассмотрим, как объект может быть escaped.

1. Объявить поле как `public static`, так что любой класс или тред может получить к нему доступ

2. Предоставить getter для private поля

3. Передать объект в *alien метод*. С перспективы класса C, для него alien метод тот, спецификация и поведение которого не определяется самим классом C. Это включает методы других классов, а также overrideable методы (ни private ни final) самого класса C. Передача объекта в alien метода считается публикацией объекта, так как мы не знаем, что этот метод будет делать с объектом, т.к. мы его не контролируем. Alien метод может запаблишить объект или сохранить ссылку на него, так что другой тред в будущем заиспользует эту ссылку. Не важно, что делает именно другой тред. Всегда есть риск, что другой класс или тред могут злоупотребить, явно или неявно, объектом.

4. Публикация this ссылки. Это делается через публикацию inner class instance (inner class - это non-static nested класс), а как мы знаем, inner класс содержит скрытую ссылку на enclosing instance. Из стандарта: `Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private. Static nested classes do not have access to other members of the enclosing class`. Пример:
```java
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(
            new EventListener() {
                public void onEvent(Event e) {
                    doSomething(e);
                }
            });
    }
}
```

Мы паблишим EventListener, а он содержит скрытую ссылку на ThisEscape, через которую можно получить все поля enclosing класса, даже private. Сам же enclosing объект можно получить через выражение `ThisEscape.this`.

#### 3.2.1 Safe Construction Practices

Прошлый пример показал, как this reference может утечь во время конструкции объекта (т.е. во время работы конструктора). Это очень опасно, так как такой объект, конструктор которого еще не завершился, но ссылка на который утекла, считается не до конца сконструированным, находится в неконсистентном состоянии. Это правда, даже если публикация - это последнее выражение в конструкторе (смотри прошлый пример - там публикация это единственное выражение в конструкторе ThisEscape).

Два примера, как ссылка может утечь во время конструкции объекта:
1. Запуск треда из конструктора. Тогда запущенный тред сможет получить доступ к полям еще не завершившего конструкцию объекта, так как класс Thread будет считаться inner классом (а конкретно, anonymous классом). Здесь говорится именно о запуске треда, а не о конструкции. Лучший способ избежать этого - предоставить отдельный метод для запуска треда, а конструировать тред в конструкторе.
2. Вызов overrideable instance метода из конструктора (private и final методы не считаются). Тогда методы того же класса также могут получить достук к полям еще не завершившего конструкцию объекта.
3. Вызов метода другого класса с передачей this ссылки

Мы не можем избежать публикации скрытой this ссылки на enclosing класс, так как так работает сама джава, однако мы должны избегать её публикации во время работы конструктора.

### 3.3 Thread Confinement

Thread Confinement - ограничение свободы тредов, ограничение дозволенности тредов.

Доступ shared mutable данных требует синхронизации. Один путь избежать этого требования - не шарить данные. Если данные доступны только из одного треда, то синхронизация не понадобится. Эта техника называется **Thread Confinement**. Если объект confined к треду, то такое использование объекта безопасно, даже если сам объект не является безопасным.

Swing использует эту технику: Swing visual components и data model объекты не безопасны сами по себе; вместо этого, они confined к Event Dispatch треду. Другие треды для правильного функционирования приложения не должны трогать эти объекты. Для того, чтобы обновить эти объекты из других тредов, эти треды должны попросить Event Dispatch Thread обновить эти объекты - это делается через `invokeLater` механизм, который шедулит Runnable для исполнения в event dispatch треде).

Также эта техника используется в pooled JDBC. JDBC спецификация не требует от объектов `Connection` быть thread-safe, но вместо этого тред получает Connection из пула коннекшенов, использует его для синхронного обслуживания запроса в одном треде, и возвращает обратно в пул. В это время пул не дает тот же Connection другим тредам, пока он не вернулся. Такой паттерн неявно привязывает (confines) Connection объект к единственному треду.

Так как в джаве нет механизма для гарантирования Thread Confinement, то правильное использование этой техники должно принуждаться только самой имплементацией приложения. Джава и библиотеки предоставляют механизмы, которые могут помочь в обеспечении правильности использования этой техники - например, локальные переменные или ThreadLocal класс, но все равно, гарантирование, что объект не покинет тред, зависит от программиста.

#### 3.3.1 Ad-hoc Thread Confinement

Ad-hoc - when necessary or needed, то есть использование только в случае нужды

Пример использования:
> an ad hoc committee/meeting

>> We deal with problems on an ad hoc basis (= as they happen).

Здесь говорится про то, что необходимость (то есть ad-hoc) Thread Confinement появляется только в последствии решения сделать систему single-threaded. Однако, Thread confinement крайней fragile, потому что правильное использование техники ложится только на программиста, и джава не сильно помогает в этом.

Да, иногда, single-threaded система имеет больше плюсов, чем имеет минусов Thread Confinement. Такзже специальный кейс Thread Confinement - легкость использования volatile переменных. Как мы помним, это безопасно использовать read-mofidy-write операции на volatile переменной до тех пор, пока в нее пишет только 1 тред, а Thread Confinement дает нам как раз это.

Существует две наиболее сильные формы Thread Confinement
* Stack Confinement (#3.3.2), где переменные хранятся только в локальных переменных. то есть в стеке одного треда, а его стек не доступен из других тредов. Также это называется within-thread или thread-local confinement (не путать с классом ThreadLocal в джаве, следующий пункт)
* ThreadLocal Confinement (#3.3.3) - переменные хранятся в ThreadLocal объектах. Глобальный ThreadLocal объект возвращает каждому треду отдельную копию объекта, хранящегося в ThreadLocal объекте. Пример использования:

```java
public class ThreadLocalExample {
    private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
        public Connection initialValue() {
            return DriverManager.getConnection(DB_URL);
        }
    };
    public static Connection getConnection() {
        return connectionHolder.get();
    }
}
```

### 3.4. Immutability

Другой способ избежать синхронизации - это использование immutable объектов (только реально immutable! об этом писалось в Effective Java, иммутабельность надо очень хорошо проверять).

Вообще, все проблемы с обозреванием объекта в неконсистентом состоянии, обозреванием stale (non-recent) значений, не видимостью обновлений, происходят из того, что несколько тредов пытаются обновлять mutable состояние объекта.

Иммутабельные объекты от природы thread-safe: их инварианты устанавливаются конструктором, а так как состояние такого объекта нельзя изменить, то и инварианты сохраняются всегда. Ясно, что иммутабельные объекты можно не боясь шарить и паблишить.

Глобальные иммутабельные объекты часто следует использовать вместе с volatile для паблиша обновления состояния immutable объекта (обновление состояния происходит через замену старого immutable объекта на новый инстанс immutable объекта). Использование immutable объекта + volatile позволяет классу позволяет быть thread-safe, избегая explicit локов.

### 3.5. Safe Publication

