# Java Concurrency In Practice, Brian Goetz

### Chapter 1: Introduction

### Что такое event loop (общее понятие)?

**Event loop (цикл событий)** - это луп, который ожидает новых ивентов, а далее передает ивент в обработчик ивента. Ивент луп работает, делая запросы к *event provider* и ожидая их (например, сокет), а затем вызывает необходимый *event handler* (диспатчит ивент. Например, обработчик http запроса).

https://en.wikipedia.org/wiki/Event_loop

Можно представить его так:
```c
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

Новые GUI фреймворки заменили event loop на event dispatch thread (EDT).

Вообще, как связаны здесь GUI приложения и ивенты? Дело в том, что действия юзера - это все какие-то ивенты, и каждое действие пользователя должно вызывать какие-то изменения, их надо как-то обрабатывать. Поэтому event-driven парадигма так популярна в GUI приложениях.

Event loop и EDT - это все об event-driven парадигме программирования.

### Liveness hazards

Для начала, надо разобраться, что такое liveness.

*Liveness* - живучесть приложения, возможность делать какой-то прогресс, даже если конкуррентно выполняющиеся компоненты ожидают вхождения в критическую секцию.

То есть, если safety означает "nothing bad ever happens", то liveness говорит: "something good eventually happens". Liveness failure происходит, когда состояние приложение таково, что оно не может делать даже постепенный прогресс.

Существует разные варианты liveness:
- freedom from deadlock
- freedom from starvation
- freedom from livelock

### Почему вообще баги связанные с конкуррентностью тяжело обнаружимы?

Потому что многое зависит от порядка выполнения операций. Тебе постоянно надо думать, что если A произойдет перед B, произойдет после B и т.д.

---

## Part 1: Fundamentals

### Chapter 2: Thread Safety
Самое правильное возможное определение thread safety дано именно в данной книге.

- **Thread safety** - класс является thread-safe, если он ведет себя *корректно* когда используется несколькими тредами, в независимости от стратегии шедулинга или порядка операций в тредах, и без дополнительной синхронизации с вызывающей стороны.

Я не зря выделил здесь слово *корректно*: корректность - это соответствие поведения класса дизайну класса, предписанным инвариантам и пост эффектам.

- **Thread safe** класс инкапсулирует необходимую синхронизацию в реализации, так что клиентам не приходится делать синхронизацию при работе с классом.

**Про состояние объекта:**

Что такое Object's state вообще? Object's state - это дата, которая содержится в полях объекта (инстансы и статические поля).

Вообще, thread safety - это именно о состоянии, а не о коде. Мы говорим о thread safety когда смотрим на кусок кода, который инкапсулирует свое состояние, а этот кусок кода может быть объектом или целой программой.

#### Race condition

**Race condition** - это о порядке действий, об их тайминге. Race condition - это возможность некорректного результата когда два треда из-за неудачного тайминга действий могут выдать некорректный результат, сделать что-то плохое. Простой пример - инкремент int или long переменной из двух тредов с помощью операции инкремента `++` без синхронизации.

Кстати, нельзя путать термин race condition с термином *data race*, который означает то, что синхронизация не используется при работе с shared non-final полем. Мы рискуем получить дата рейс, когда пишем в переменную, которая может быть прочитана другим полем, и когда читаем переменную, в которую другой тред мог что-то записать. Дата рейсы будут разобраны позже (Chapter 16). Не все race conditions это data races, и не все data races это race conditions, но часто они могут присутствовать оба. Например, в ситуации с инкрементом есть и race condition, и data race.

Самый популярный вид race condition - это check-then-act. Сначала мы проверяем условие X, далее в зависимости от верности предиката X делаем какое-то действие, но в момент между проверкой и действием условие могло стать невалидным из-за действий другого треда. Таким образом, валидность результат зависит от тайминга действий, т.е. мы имеем race condition.

Где может быть check-then-act race condition? Самый распространенный случай - это lazy initialization (т.е. конструкция вида `if (object == null) object = new Object`).

### Locks

Локи позволяют обеспечить exclusive access к критической секции. А что такое *критичесская секция*?

**Критическая секция** может являться как shared данными, так и набором операций, которые должны быть выполнены атомарно.

То есть эти 2 утверждения:
1. Локи позволяют обеспечить exclusive access к shared данным
2. Локи нужны, чтобы превратить compound операции, такие как check-then-act и read-modify-write операции в атомарные

полностью покрываются утверждением выше.

#### Intrinsic Locks

Intrinsic Lock - лок, который построен на основе внутренней сущности класса (какого-то поля или самого объекта, т.е. this).

Пример intrinsic лока в джаве - `synchronized`. Если `synchronized` применено к методу, то для лока используется сам объект (this).

Каждый Java объект может использоваться в качестве лока. Вообще, правильнее сказать, что каждый Java объект имеет intrinsic лок (под него выделяется память когда создается новый объект), и его остается только получить с помощью `synchronized`.

#### Reentrancy

Да, тред не может получить лок, который захвачен другим тредом. Однако, intrinsic лок может быть получен снова тем же тредом, который его захватил. Свойство повторно получить лок в том же треде, который раннее уже захватил этот лок, называется **reentrancy**.

Reentrancy обозначает, что лок получается на per-thread, а не per-invocation базисе. То есть лок может получить только 1 тред, но и дальнейшее его использование возможно в том же треде.

Reentrancy реализовано так: с каждым локом ассоциируется owner тред и счетчик захватов. Если счетчик равен 0, то лок считается свободным. Когда тред захватывает лок, устанавливается owner thread и счетчик инкрементируется до 1. Когда тот же тред снова захватывает лок, то счетчик опять инкрементируется. Когда тред выходит из synchronized блока кода, счетчик декрементируется. Когда счетчик достигает 0, то лок освобождается.

### Guarding State with Locks

Нельзя думать, что локи нужны только для записи в объект - даже чтение должно производиться через этот лок. Это так по следующим причинам:
 1. Если операции записи закрывать в synchronized блок, а операции чтения нет, то операции чтения могут прочитать половинное значение, а мы, используя локи, добиваемся именно атомарности
 2. synchronized должен использоваться для чтения потому, что таким образом обеспечивается, что write happens-before read (стандарт гарантирует это для synchronized) - то есть достигается видимость изменений, осуществленных в write операциях.

Более того, если объект может быть использован несколькими тредами, то все доступы к этому объекту должны быть обеспечиваться **одним и тем же локом**. В таком случае, мы говорим, что объект guarded by this lock. Когда класс имеет инвариант, который включает в себя больше одной переменной (то есть инвариант накладывает связывает как-то эти переменные), то все эти переменные также должны быть защищены (guarded) одним и тем же локом. Это позволяет нам изменять их в единой атомарной операции, сохраняя инвариант.

Также, каждая изменяемая shared переменная должна быть защищена **только одним локом**. То есть все действия с ней должны делаться только через один лок.

### Liveness and Performance

Один совет: исключать long-running операции (это или compute-intensive или I/O blocking операции) из синхронизированных блоков кода и оставлять в таких блоках только действия, относящиеся к mutual состоянию объекта. Таким образом, мы можем не сильно замедлять производительность.

--

## Chapter 3: Sharing Objects

Мы видели, как synchronized блоки кода могут обеспечить эксклюзивный доступ к критической секции, но не стоит думать, что `synchronized` используется только для этого. В многопоточном мире есть такое понятие, как **memory visibility** - видимость изменений одного треда в других тредах. Мы хотим не только избежать race condition, но и сделать так, чтобы изменения были видимы для других тредов.

Synchronized гарантирует happens-before отношение для любого последующего вызова synchronized на том же объекте (именно на объекте, не важно какой intrinsic лок используется), то есть все действия в первом synchronized блоке произошли гарантированно перед следующим вызовом synchronized метода (а как мы знаем, JVM может менять порядок операций, поэтому это важно).

### 3.1. Visibility

Видимость вообще уточенная штука. Дело в том, что изменения одного треда могут быть не видны другим тредам вообще никогда или же порядок операций может меняться.

Вот пример:
```java
public class NoVisibility {
    private static boolean ready;
    private static int number;
    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready) Thread.yield();
            System.out.println(number);
        }
    }
    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```

Здесь может произойти 2 вещи:
1. Запись в ready может быть не видна ожидающему треду никогда - здесь проблема видимости
2. Запись в ready произойдет до записи в number, и станет видна ожидающему треду, тогда ожидающий тред выведет 0, т.е. дефолтное значение int, но здесь могло быть null в случае объекта. В любом случае, в более сложном кейсе дальнейшая работа с неустановленным значением привела бы к неправильному результату - здесь проблема reordering операций

Reordering может быть не только в JVM, но и в компиляторе и процессоре. Мы не должны ничего предпологать о порядке операций, и полагаться на это при разработке конкуррентных программ. Если же happens before гарантируется стандартом, только тогда мы можем быть уверены что одни операции выполнятся перед другими.

Простой способ избежать этого - использовать синхронизацию при доступе к shared данным.

#### 3.1.2. Non-atomic 64 bit операции

JMM гарантирует, что store и read операции атомарны для всех типов объектов, за исключением long и double, которые не объявлены как volatile или не защищены локом. Тогда есть опасность того, что при записи одним тредов в long или double переменную другой тред увидит половинное значение: 32 бита одной совершенной операции, и 32 бита от прошлого значения, т.е. получит некорректное значение.

#### 3.1.3. Locking and Visibility

Тут говорится о том, что синхронизация должна использоваться и для visibility, а не только для mutual exclusion тредов.

Конкретно здесь говорится о чем я уже говорил: 
> Synchronized гарантирует happens-before отношение для любого последующего вызова synchronized на том же объекте (именно на объекте, не важно какой intrinsic лок используется), то есть все действия в первом synchronized блоке произошли гарантированно перед следующим вызовом synchronized метода (а как мы знаем, JVM может менять порядок операций, поэтому это важно).

#### 3.1.4. Volatile variables

Джава предлагает более слабую альтернативу синхронизации, но более производительную - **volatile**. Volatile гарантирует следующие вещи:

1. Операции с переменной, объявленной как volatile, не будут reordered и порядок для них сохранится, как в коде
2. Значения не будут кэшированы и чтение всегда получит самое последнее опубликованное значение

На самом деле, эффекты видимости volatile переменной выходят за пределы самой volatile переменной. Дело в том, что когда тред A пишет в volatile переменную и тред B последовательно читает ее значение, значения переменных, которые были видны треду A до записи в volatile переменную, становятся видны и треду B после чтения volatile переменной. То есть, о volatile можно думать так: запись в volatile - это выход из synchronized блока, а чтение из volatile - это вход в synchronized блок. Однако, не стоит сильно полагаться на это. Гораздо лучше использовать volatile только для первых 2 гарантированных вещей, а не таких эффектов видимости. Такой код опасен и сложнее понятен.

Таким образом, следует использовать *volatile* только тогда, когда они упрощают разработку политики синхронизации. Не следует их использовать, когда проверка корректности требовала бы думать о видимости других состояний. То есть, использовать volatile стоит, когда оно включает в себя только состояние самой volatile переменной.

Volatile можно использовать только тогда, когда в переменную пишет всегда только 1 тред, а другие только читают. Тогда read-modify-write операции на ней безопасны. Почему это так? Потому что TODO: узнать почему так

Самый распространненый случай volatile - это completion, interruption или status flag.

Локинг гарантирует нам как visibility, так и atomicity, а volatile - только visibility. Поэтому, например, операция инкремента на volatile переменной не является атомарной до тех пор, пока мы не можем гарантировать, что в переменную пишет всегда только 1 тред (увеличивает счетчик только 1 тред). Тогда не будет конкурретности записи и другие треды не смогут увидеть значение до modify-write шага и установить то же значение, что и первый тред.

Вообще, отвлекусь. Что такое атомарная операция инкремента? Атомарная операция инкремента должна увеличивать счетчик за 1 шаг (а не 3: read-modify-write). Поэтому в ней используется cas-луп или мьютекст для того, чтобы гарантировать, что операция инкремента действительно заняла 1 шаг. Что по сути означает 1 шаг? Это означает как бы, что это одна инструкция, а если cas возвращает false, то значит что в нашу инструкцию кто-то вмешался, и это был нифига не 1 шаг. Чтобы выглядело все как 1 шаг, все шаги read-modify-write должны выполниться сразу без конкурренции.

Итак, использовать volatile можно только тогда, когда выполнены следующие условия:
- Запись в volatile переменную не зависит от её текущего значения, или мы можем гарантировать, что в переменную пишет всегда только 1 тред
- Переменная не участвует вместе с другими переменными в инварианте (так как для поддержания инварианта нам требуется атомарность, то есть обновлять переменные, участвующие в инварианте, требуется атомарно)
- Локинг не требуется при доступе к переменной

### 3.2. Publication and Escape

**Публикация объекта** - это делание его видимым в коде вне текущего scope, такое как сохранение ссылки на объект где другой код может получить эту ссылку, возвращая объект из non-private метода или передавая объект в метод другого класса. Заметь, здесь нет ничего про многопоточность.

Во одних ситуациях мы хотим чтобы инкапсуляция не нарушалась и объект не был запаблишен. В других ситуациях мы хотим публикации объекта, однако делание этого thread-safe образом может потребовать некоторой синхронизации.

Ситуация, когда объект был запаблишен когда он не должен был называется **escape**, и говорится, что *object escaped.*
Стоит понимать, что если какой-нибудь объект доступен из запаблишенного объекта, то и он становится неявно запаблишенным. Например, запаблишенный массив объектов предоставляет доступ к элементам самого массива.

Далее мы рассмотрим, как объект может быть escaped.

1. Объявить поле как `public static`, так что любой класс или тред может получить к нему доступ

2. Предоставить getter для private поля

3. Передать объект в *alien метод*. С перспективы класса C, для него alien метод тот, спецификация и поведение которого не определяется самим классом C. Это включает методы других классов, а также overrideable методы (ни private ни final) самого класса C. Передача объекта в alien метода считается публикацией объекта, так как мы не знаем, что этот метод будет делать с объектом, т.к. мы его не контролируем. Alien метод может запаблишить объект или сохранить ссылку на него, так что другой тред в будущем заиспользует эту ссылку. Не важно, что делает именно другой тред. Всегда есть риск, что другой класс или тред могут злоупотребить, явно или неявно, объектом.

4. Публикация this ссылки. Это делается через публикацию inner class instance (inner class - это non-static nested класс), а как мы знаем, inner класс содержит скрытую ссылку на enclosing instance. Из стандарта: `Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private. Static nested classes do not have access to other members of the enclosing class`. Пример:
```java
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(
            new EventListener() {
                public void onEvent(Event e) {
                    doSomething(e);
                }
            });
    }
}
```

Мы паблишим EventListener, а он содержит скрытую ссылку на ThisEscape, через которую можно получить все поля enclosing класса, даже private. Сам же enclosing объект можно получить через выражение `ThisEscape.this`.

#### 3.2.1. Safe Construction Practices

Прошлый пример показал, как this reference может утечь во время конструкции объекта (т.е. во время работы конструктора). Это очень опасно, так как такой объект, конструктор которого еще не завершился, но ссылка на который утекла, считается не до конца сконструированным, находится в неконсистентном состоянии. Это правда, даже если публикация - это последнее выражение в конструкторе (смотри прошлый пример - там публикация это единственное выражение в конструкторе ThisEscape).

Два примера, как ссылка может утечь во время конструкции объекта:
1. Запуск треда из конструктора. Тогда запущенный тред сможет получить доступ к полям еще не завершившего конструкцию объекта, так как класс Thread будет считаться inner классом (а конкретно, anonymous классом). Здесь говорится именно о запуске треда, а не о конструкции. Лучший способ избежать этого - предоставить отдельный метод для запуска треда, а конструировать тред в конструкторе.
2. Вызов overrideable instance метода из конструктора (private и final методы не считаются). Тогда методы того же класса также могут получить достук к полям еще не завершившего конструкцию объекта.
3. Вызов метода другого класса с передачей this ссылки

Мы не можем избежать публикации скрытой this ссылки на enclosing класс, так как так работает сама джава, однако мы должны избегать её публикации во время работы конструктора.

### 3.3. Thread Confinement

Thread Confinement - ограничение свободы тредов, ограничение дозволенности тредов.

Доступ shared mutable данных требует синхронизации. Один путь избежать этого требования - не шарить данные. Если данные доступны только из одного треда, то синхронизация не понадобится. Эта техника называется **Thread Confinement**. Если объект confined к треду, то такое использование объекта безопасно, даже если сам объект не является безопасным.

Swing использует эту технику: Swing visual components и data model объекты не безопасны сами по себе; вместо этого, они confined к Event Dispatch треду. Другие треды для правильного функционирования приложения не должны трогать эти объекты. Для того, чтобы обновить эти объекты из других тредов, эти треды должны попросить Event Dispatch Thread обновить эти объекты - это делается через `invokeLater` механизм, который шедулит Runnable для исполнения в event dispatch треде).

Также эта техника используется в pooled JDBC. JDBC спецификация не требует от объектов `Connection` быть thread-safe, но вместо этого тред получает Connection из пула коннекшенов, использует его для синхронного обслуживания запроса в одном треде, и возвращает обратно в пул. В это время пул не дает тот же Connection другим тредам, пока он не вернулся. Такой паттерн неявно привязывает (confines) Connection объект к единственному треду.

Так как в джаве нет механизма для гарантирования Thread Confinement, то правильное использование этой техники должно принуждаться только самой имплементацией приложения. Джава и библиотеки предоставляют механизмы, которые могут помочь в обеспечении правильности использования этой техники - например, локальные переменные или ThreadLocal класс, но все равно, гарантирование, что объект не покинет тред, зависит от программиста.

#### 3.3.1. Ad-hoc Thread Confinement

Ad-hoc - when necessary or needed, то есть использование только в случае нужды

Пример использования:
> an ad hoc committee/meeting

>> We deal with problems on an ad hoc basis (= as they happen).

Здесь говорится про то, что необходимость (то есть ad-hoc) Thread Confinement появляется только в последствии решения сделать систему single-threaded. Однако, Thread confinement крайней fragile, потому что правильное использование техники ложится только на программиста, и джава не сильно помогает в этом.

Да, иногда, single-threaded система имеет больше плюсов, чем имеет минусов Thread Confinement. Такзже специальный кейс Thread Confinement - легкость использования volatile переменных. Как мы помним, это безопасно использовать read-mofidy-write операции на volatile переменной до тех пор, пока в нее пишет только 1 тред, а Thread Confinement дает нам как раз это.

Существует две наиболее сильные формы Thread Confinement
* Stack Confinement (#3.3.2), где переменные хранятся только в локальных переменных. то есть в стеке одного треда, а его стек не доступен из других тредов. Также это называется within-thread или thread-local confinement (не путать с классом ThreadLocal в джаве, следующий пункт)
* ThreadLocal Confinement (#3.3.3) - переменные хранятся в ThreadLocal объектах. Глобальный ThreadLocal объект возвращает каждому треду отдельную копию объекта, хранящегося в ThreadLocal объекте. Пример использования:

```java
public class ThreadLocalExample {
    private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
        public Connection initialValue() {
            return DriverManager.getConnection(DB_URL);
        }
    };
    public static Connection getConnection() {
        return connectionHolder.get();
    }
}
```

### 3.4. Immutability

Другой способ избежать синхронизации - это использование immutable объектов (только реально immutable! об этом писалось в Effective Java, иммутабельность надо очень хорошо проверять).

Вообще, все проблемы с обозреванием объекта в неконсистентом состоянии, обозреванием stale (non-recent) значений, не видимостью обновлений, происходят из того, что несколько тредов пытаются обновлять mutable состояние объекта.

Иммутабельные объекты от природы thread-safe: их инварианты устанавливаются конструктором, а так как состояние такого объекта нельзя изменить, то и инварианты сохраняются всегда. Ясно, что иммутабельные объекты можно не боясь шарить и паблишить.

Глобальные иммутабельные объекты часто следует использовать вместе с volatile для паблиша обновления состояния immutable объекта (обновление состояния происходит через замену старого immutable объекта на новый инстанс immutable объекта). Использование immutable объекта + volatile позволяет классу позволяет быть thread-safe, избегая explicit локов.

### 3.5. Safe Publication

В данной главе мы обсудим, как правильно паблишить объекты. Ясно, что сохранения объекта в public поле или предоставления геттера не достаточно.

Вообще, из-за неправильной публикации может быть 2 плохие вещи:
1. Другие треды могут увидеть старое значение для переменной, а это или null или старое значение
2. Другие треды могут увидеть up to date значение для ссылки на переменную, но stale состояние переменной

Последний кейс особенно прикольный. Дело в том, что конструктор `Object` сначала устанавливает значения по-умолчанию для всех полей, и только затем вызывается сабконструктор (как мы помним, все классы наследуются неявно от Object в джаве). Так вот, хоть и ссылка может обнаружиться up-to-date, но внутренние поля класса не гарантируются быть обнаруженными тоже up-to-date. TODO: узнать правда ли это так?

Вот пример такого класса:
```java
public class Holder {
    private int n;
    public Holder(int n) {
        this.n = n;
    }
    public void assertSanity() {
        if (n != n) throw new AssertionError("This statement is false.");
    }
}
```

При неправильной публикации здесь проверка может запросто упасть из-за того, что при первом чтении было обнаружено default значение, а при втором чтении - внутреннее поле `n` стало up-to-date тоже, просто с запозданием.

#### 3.5.2. Immutable Objects and Initialization Safety

Так как immutable объекты крайне важны вообще в мире программирования, то в JMM для них существют специальные гарантии.

Как мы видели ранее, обнаружение up to date ссылки на объект еще не гарантирует, что и состояние объекта будет тоже up to date. Чтобы гарантировать консистентное состояние объекта, требуется синхронизация.

Иммутабельные объекты, в свою очередь, могут быть безопасно просматриваться, даже если синхронизация не использовалась при публикации. Для этого все поля класса должны быть `final`. Джава гарантирует, что в `final` полях всегда будет up-to-date значение. Однако, если по final полю находится mutable объект, синхронизация, конечно же, все еще требуется.

#### 3.5.3. Safe Publication Idioms

Здесь описываются правила безопасной публикации только что сконструированного объекта. О видимости изменений, сделанных после публикации, мы поговорим позже. Да, данные вещи стоит разделять.

Чтобы опубликовать объект безопасно, оба, и ссылка, и состояние объекта должны быть видимы другим тредам в одно и то же время. Правильно сконструированный объект может быть безопасно опубликован с помощью:
- Инициализация ссылки на объект из *static initializer* (`public static Holder holder = new Holder(42);`)
- Храня ссылку на объект в *volatile* или *AtomicReference* поле
- Храня ссылка на объект в *final* поле
- Храня ссылка на объект в поле, которое защищено локом (guarded by lock)

#### 3.5.4. Effectively Immutable Objects

При правильной конструкции объекта, все safe publication механизмы, описанные выше, гарантируют, что состояние будет консистентным как только ссылка на объект становится видной. И если состояние не собирается изменяться в дальнейшем, то этого достаточно для безопасного использования объекта без какой-то синхронизации.

Такие объекты, которые не являются иммутабельными, но чье состояние не будет изменено после публикации, называются **effectively immutable**. Использование таких объектов может облегчить разработку, но в то же время повышает вероятность ошибок, и с ними следует обходиться осторожно.

#### 3.5.5. Mutable Objects

Если же объект собирается быть измененным в дальнейшем, то должна использоваться синхронизция не только для публикации изменений, но и при доступе к объекту для видимости изменений.

Таким образом, чтобы шарить mutable объекты безопасно, они должны быть безопасно опубликованы и должны быть thread-safe или защищены локом.

Подведем итог безопасной публикации объектов. Как объект должен быть опубликован, зависит от его изменяемости:
- **Immutable** - может быть опубликован любым способом
- **Effectively immutable** - должен быть безопасно опубликован (одним из способов, описанных выше)
- **Mutable** - должен быть безопасно опубликован (одним из способов, описанных выше), а также должен быть thread-safe или защищен локом

Напомню, thread-safe объект делает всю синхронизацию внутренне и может использоваться без дополнительной синхронизации. Мы говорим, "защищен локом", если для работы с объектом исползуется дополнительная синхронизация.

---

## Chapter 4: Composing Objects

До этого момента мы фокусировались на low-level аспектах thread safety и синхронизации. Но мы не хотим анализировать каждый кусочек доступа к памяти: мы хотим брать thread-safe компоненты и безопасно компоновать их в бОльшие компоненты и программы. В этой главе описываются паттерны конструирования классов, которые помогут сделать их thread-safe и случайно не нарушить их thread safety гарантии.

### 4.1. Designing a Thread-safe Class

Процесс дизайна thread-safe классов должен выключать следующие 3 базовых элемента:
- Определить переменные, которые формируют состояние объекта
- Определить инварианты, которые ограничивают переменные-состояния
- Установить политику конкуррентного доступа к состоянию объекта

Если объект A содержит поле-ссылку на другой объект B, в котором также существуют переменные-состояния, то и эти поля входят в состав состояния объекта A. Например, состояние LinkedList включает в себя состояния всех nodes принадлежащих листу.

Что такое политика синхронизации (synchronization policy)? **Политика синхронизации** определяет, как объект координирует доступ к своему состоянию без нарушения своих инвариантов и post-conditions (пост-эффектов). Политика синхронизации задает комбинацию иммутабельности, thread confinement, локинга для поддержания thread safety, а также говорит, какими локами защищены переменные. Чтобы анализировать и поддерживать класс более легко, всегда документируйте политику синхронизации.

#### 4.1.1. Gathering Synchronization Requirement

Делание класса thread-safe обозначает поддержание его инвариантов под конкуррентным доступом, а это требует думать о состоянии объекта.

Переменные и объекты имеют **пространство состояний**: диапазон возможных состояний, которые может принимать переменная/объект.

Аналогично, операции могут иметь **post-conditions**, которые определяют некоторые state transitions как невалидные. Например, если состояние счетчика 17, то следующее валидное его состояние - только 18. 

Здесь замечу: если следующее состояние наследуется (зависит) от предыдущего состояния, то операция считается compound операцией - а такая операция должна быть обязательно атомарной. Однако, не все операции имеют ограничения на state transitions. Например, если обновлять показания температуры, то новое состояние не зависит от прошлого.

Ограничения, наложенные на состояния или стейт транзишены инвариантами и пост-эффектами, требуют дополнительной синхронизации или инкапсуляции. Если какое-то состояние считается невалидное, или переменная имеет невалидные переходы, то состояние необходимо инкапсулировать, не позволяя клиенту класса перевести объект в невалидное состояние.

Класс также может иметь ограничения, включающие несколько переменных. Как я уже говорил, такие переменные должны обновляться в одной атомарной операции. Нельзя обновить одну переменную, а затем другую как отдельную операцию - так возникает окно, во время которого инвариант нарушается, а значит класс находится в невалидном состоянии.

Итак, выделю самую важную мысль: мы не можем убедиться в thread safety класса до тех пор, пока не определим инварианты и пост-эффекты. Именно ограничения на валидные значения и валидные переходы состояний создают требования атомарности и синхронизации.

#### 4.1.2. State-dependent Operations

Инварианты класса и post-conditions метода ограничивают валидные состояния и переходы состояний. Однако, некоторые методы классов имеют также state-based preconditions. Например, мы не можем удалить элемент из пустой очереди. Такие операции с state-based preconditions называются state-dependent. 

В single-threaded системе такая операция, если не выполняется precondition, имеет только единственный выбор упасть с исключением. Но в конкуррентной среде это preconditions может выполниться, но только позже, из-за действий другого треда. Поэтому конкуррентные программы добавляют возможность ожидания выполнения preconditions, и последующего выполнения state-dependent операции на валидном состоянии.

Build-in механизмы для ожидания (wait и notify) крайне сильно привязаны к intrinsic локингу (так как wait и notify работают на самом объекте), поэтому не рекомендуется использовать их. Для написания методов, которые могут ожидать выполнения preconditions, лучше следует использовать существующие стандартные библиотеки, например, такие классы как BlockingQueue и Semaphore.

### 4.2. Instance Confinement

Если объект сам по себе не является thread-safe, то мы все еще можем гарантировать безопасный доступ к нему: через Thread Confinement или же защитив его локом.

Instance Confinement - это об заключении объекта в другой объект, таким образом ограничивая пути доступа к объекту до путей доступа до enclosing объекта, и более того, до методов enclosing объекта, вместо того, чтобы предоставлять доступ из всей программы, а также это позволяет нам гарантировать то, что доступ к объету происходит через правильный лок.

Confined объекты не должны сбегать из их договоренной области видимости. Как объекты могут сбегать, мы уже обсуждали раннее (Publication and Escape).

Объект может быть confined to (заключен в):
- class instance (например, приватное поле)
- lexical scope (например, локальная переменная)
- thread (например, объект передается из метода в метод, но в одном треде)

Instance Confinement (также называемый просто как Confinement) - наиболее простой способ обеспечить thread safe доступ к объекту. Также это предоставляет гибкость в выборе стратегии локинга, так как мы даем только API enclosing класса, а как оно устроено внутри - не важно.

Есть много примеров confinement'а в стандартных библиотеках. Например, factory метод `Collections.synchronizedList` и другие заключают внутри себя List и предоставляют синхронизированное API, которое делегирует запросы к коллекции внутри. Такие factory методы используют паттерн Декоратор - просто оборачивают объект для превращения non thread-safe объекта в thread safe. Однако, здесь важно заметить то, что право ownership передается теперь wrapper объекту, и нижележащую коллекцию следует использовать только через wrapper объект, иначе thread safety нарушится.

#### 4.2.1. The Java Monitor Pattern

Instance Confinement логически подводит нас к паттерну Монитор. Класс, следующий этому паттерну, инкапсулирует все свои изменяемые (mutable) состояния и зищащет их intrinsic локами.

Хоть данный патерн и не позволяет предоставить fine-grained политику синхронизации, но этот паттерн явялется наиболее простым способом синхронизации.

Стоит заметить, что для защиты состояний лучше следует использовать внутренний приватный лок, а не сам объект или какой-то другой публичный лок объекта, иначе клиент может вмешиваться в политику синхронизации, и явно или неявно может помешать синхронизации, используя сам объект или публичный лок объекта как intrinsic лок. Классы, которые неправильно используют публично открытый лок другого класса, могут вызвать liveness проблемы. Также открытость лока заставляет нас проверять всю программу, а не только единичный класс, для гарантии того, что лок используется верным способом и сам класс является thread safe.

### 4.3. Delegating Thread Safety

Здесь говорится о том, что если класс состоит из Thread Safe компонентов, и класс не имеет инвариантов, включащих несколько переменных, а также у операций не может быть невалидного перехода состояний (если что, тут может меняться состояние, потому что мы говорим о Thread Safety, а не об иммутабельности), то мы можем делегировать ответственность за Thread Safety этим внутренним компонентам. То есть переменные полностью определяют Thread Safety класса. Таким образом, все thread safe переменные класса, должны быть independent, иначе делегация фейлится и мы должны добавть дополнительную синхронизацию.

Но очень важно здесь смотреть на то, имеет ли класс свои post-conditions. Если какое-то состояние считается невалидным, то мы должны добавить дополнительную синхронизацию.

#### 4.3.4. Publishing Underlying State Variables

Здесь говорится о том, когда мы можем запаблишить низлежащую thread-safe переменную класса.

Для этого должны выполняться следующие условия:
- Переменная, конечно же, должна быть thread safe
- Переменная не входит в никакой инвариант класса
- Переменная не имеет невалидных стейт транзишенов для любой операции на себе

Тогда мы можем запаблишить переменную, и любые изменения клиента на ней (в обход enclosing класса) не смогут нарушить Thread Safety enclosing класса.

### 4.4. Adding Functionality to Existing Thread-safe Classes

Добавление новой функциональности к существующему Thread Safe классу всегда должно заставить вас думать: какая политика синхронизации у оригинального класса?

Вот пример неправильного добавления `putIfAbsent` операции к существующему листу:
```java
@NotThreadSafe
public class ListHelper<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());

    public synchronized boolean putIfAbsent(E x) {
        boolean absent = !list.contains(x);
        if (absent) list.add(x);
        return absent;
    }
}
```

Казалось бы, все ок, ведь поставили synchronized и несколько вызовов не смогут положить в лист элемент одновременно? Но проблема в том, что наша операция putIfAbsent нифига не стала атомарной, потому что мы не знаем, атомарна ли она по отношению к другим операциями листа из-за того, что не знаем каким локом защищены операции самого листа! Пока мы работаем с листом в putIfAbsent, лист может в это время измениться, ведь его операции могут быть защищены другим локом и наш монитор не эксклюзивен по отношению к другим мониторам или другим локам.

#### 4.4.1. Client-side Locking

Для того, чтобы правильно добавить методы к существующему Thread Safe классу, классом должен быть предусмотрен **Client-side локинг** - то есть класс должен сказать каким локом защищены операции внутри, и более того, сделать лок публичным. Самый простой способ сделать класс возможным для расширения - использовать монитор как политику синхронизации и сделать монитор работающим на инстансе самого класса (т.е. `synchronized (this)`).

Однако, все это очень плохо. Есть другое решение - расширять класс для добавления новой атомарной операции. И вот это решение выше - использовать Client-Side locking. Но оба решения плохи - первое решение разносит код локинга по разным соурс классам и становится сложнее поддерживать все это - базовый класс и его детей, а второе решение даже еще хуже - он выносит код локинга к классу A за видимость самого класса A, а как я говорил раньше, теперь другой класс может вмешиваться в политику синхронизации этого класса A.

Эти решения имеют кое-что общее: они оба связывают поведение наследованного класса с реализацией базового класса. Также как наследование нарушает инкапсуляцию реализации базового класса, также client-side локинг нарушает инкапсуляцию политики синхронизации.

#### 4.4.2. Composition

Однако, существует более лучшая и less fragile альтернатива: **Composition**. Теперь мы будем хранить объект внутри нового класса и делегировать методы к нему, но добавлять к API свою синхронизацию, в независимости от того, используется ли уже синхронизацию в объекте уже нет. Таким образом, теперь все методы, включая новый, защищены локом, и мы не нарушили политику синхронизации внутреннего объекта, а новый класс получился также Thread Safe.

Вот пример добавления putIfAbsent:
```java
@ThreadSafe
public class ImprovedList<T> implements List<T> {
    private final List<T> list;

    public ImprovedList(List<T> list) {
        this.list = list;
    }

    public synchronized boolean putIfAbsent(T x) {
        boolean contains = list.contains(x);
        if (contains) list.add(x);
        return !contains;
    }

    public synchronized void clear() {
        list.clear();
    }     // ... similarly delegate other List methods 
}
```

Однако, понятно, что такой способ хоть и лучше, но может сильно скнизить производительность, дублируя синхронизацию.

### 4.5. Documenting Synchronization Policies

Здесь говорится о важности документации, да да да. Кратко: документируйте, насколько класс Thread Safe для клиентов, а также документируйте политику синхронизации класса для разработчиков, которые будут поддерживать этот класс.

---

## Chapter 5. Building Blocks

Предыдущая глава описывала техники построения thread-safe классов, включая делегацию Thread Safety существующим thread-safe классам.

В этой главе описываются стандартная библиотека джавы: синхронизированные коллекции (Collections.synchronizedYYY, Vector, Hashtable), итераторы и ConcurrentModificationException, конкуррентные коллекции (ConcurrentHashMap, CopyOnWriteArrayList), Blocking Queues, интеррапты, синхронизаторы.

---

# Part II: Structuring Concurrent Applications

## Chapter 6. Task Execution

Здесь говорится о политике шедулинге, конкуррентности задач.

### 6.1. Executing Tasks in Threads

Здесь говорится о выполнении задач в тредах.

Недостатки:

1. Требует создания треда, что влечет некоторые расходы памяти и времени

2. Если юзеров много, то много созданных тредов могут крашнуть приложение (это исходит из того, что нет ограничений по тому, как много тредов можно создавать)

3. Так как треды могут приостанавливаться, давая выполняться другим, а в это время они занимают память, то это накладывает нагрузку на GC

### 6.2. The Executor Framework

Раннее были рассмотрены две политики исполнения задач: последовательно (sequentially) в единственном треде и исполнение каждой задачи в отдельном треде. Но обе политики имеют ограничения: sequential решение имеет плохую отзывчивость на новые реквесты и производительность, а thread-per-task решение имеет плохое управление ресурсами.

Стоит начать с того, что есть такая штука как Thread Pool, и она позволяет лучше управлять ресурсами. Пакет java.util.concurrent предоставляет различные имплементации тред пулов как часть Executor фреймворка. Более того, Executor фреймворк позволяет отделить task submission от task execution: мы только описываем задачу, но то, как она выполнится - решает Executor. Executor основан на Producer-Consumer паттерне.

**Executor** в Java выглядит достаточно просто:
```java
public interface Executor {
    void execute(Runnable r);
}
```

#### 6.2.2. Execution Policies

Что нам дает отделение task submission от task execution? Это дает нам возможность менять политику исполнения задач (execution policy), не затрагивая код производящий задачу, а лишь меняя имплементацию экзекьютора.

Вообще, политика синхронизации определяется следующими вещами:
- В каком треде задача будет исполнена
- В каком порядке задачи будут исполнены (FIFO, LIFO, priority order)
- Как много задач могут исполняться конкуррентно
- Как много задач могут быть поставлены в очередь, ожидая выполнения
- Какие действия должны производиться перед и после выполнения задачи

Execution policy - это все о менеджементе ресурсов (resource management).

Оптимальная политика исполнения зависит от имеющихся ресурсов компьютера и quality-of-service требований. Политику исполнения можно гибко менять под деплоймент.

#### 6.2.4. Executor Lifecycle

Мы умеем создавать Executor, но не знаем, как уничтожать его правильно. Да, Executor создает треды для процессинга задач, но JVM не может выйти, пока все (non-daemon) треды не завершились, поэтому ошибка правильного уничтожения экзекьютора может помешать JVM завершиться.

Так как задачи обрабатываются асинхронно, то в каждый момент времени состояние засабмиченной задачи неочевидно: она может быть завершена, выполняться или ожидать выполнения, находясь в очереди. При выключении, здесь спектр стратегий выключения от graceful shutdown (т.е. дать всем выполняющимся задачам завершиться, включая те, которые уже засабмичены но ожидают выполнения, но не принимать новых задач) до abrupt shutdown (то есть прерывания даже выполнящихся задач и невыполнения ожидающих выполнения).

Для адресации проблемы lifecycle существует интерфейс **ExecutorService**, который расширяет Executor и добавляет методы для менеджента времени жизни, а также несколько полезных методов для сабмита задач:
```java
public interface ExecutorService extends Executor {
    void shutdown(); // graceful shutdown
    List<Runnable> shutdownNow(); // abrupt shutdown
    boolean isShutdown();     
    boolean isTerminated();     
    boolean awaitTermination(long timeout, TimeUnit unit)  
       throws InterruptedException;    
     //  ... additional convenience methods for task submission }
}
```

Методы lifecycle относятся к Executor-у. Executor считается terminated, если все засабмиченные таски завершились.

#### 6.3.2. Callable and Feature

**Callable** предназначен для тех задач, которые возвращают какой-то результат, а также могут бросать исключение. Это не интересно.

Что интереснее, это **Future**. Мы говорили раннее о lifecycle Executor-а, но задачи также имеют свой lifecycle: они могут быть created, submitted, started и completed.

В Executor фреймоворке таски, которые были засабмичены, но еще не начались выполняться, могут быть гарантированно отменены, таски которые выполняются могут быть отменены если они responsive к прерываниям (ты знаешь об обработке прерываний, да), и отмена завершенных тасков, наконец, не имеет эффекта.

*Future* представляет собой lifecycle таски и предоставляет методы для получения статуса таски (завершена или отменена), забирания результата выполнения (Future могут возвращать значения) или отмены таски.

*Future* имеет метод `get`. Данный метод возвращает `ExecutionException`, если таска завершилась бросанием исключения; возвращает `CancellationException`, если таска была прервана.

Существует несколько путей создания Future:

1. Засабмитить таску в ExecutorService с помощью создания Runnable или Callable - тогда сабмит метод возвращает Future.

2. Явно создать инстанс FutureTask для данного Runnable или Callable и засабмитить инстанс в Executor, а далее использовать этот же инстанс. Это возможно благодаря тому, что FutureTask имплементирует Runnable.

---

## Chapter 7. Cancellation and Shutdown

Здесь пойдет речь об отмене тасков и тредов. Эту тему я знаю уже достаточно, так что выпишу важные и новые вещи.

Джава не имеет хорошего и безопасного механизма отмены тредов. Вместо этого, она предоставляет **interruption** - кооперативный механизм который позволяет одному треду *попросить* другой тред остановить работу.

Кооперативный механизм требуется потому, что редко хотим останавливать задачу, тред или сервис немедленно (immediately), так как это может оставить shared структуры данных в неконсистентном состоянии. Вместо этого, таски и сервисы должны быть написаны так, что когда потребуется, они очистят ресурсы и завершат оставшуюся работу перед остановкой треда. Это лучшее решение, так как сам исполняющий работу тред знает лучше, как правильно очистить свои ресурсы, чем тот тред, который запросил остановку.

